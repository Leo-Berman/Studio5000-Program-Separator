	PROGRAM Campaign (Description := "Campaign Program$NCooresponds to cSCHEDULE tag",
	                  MAIN := "_00_CAMPAIGN_Main",
	                  MODE := 0,
	                  DisableFlag := 0,
	                  UseAsFolder := 0)
		TAG
			A : DINT (RADIX := Decimal) := 0;
			B : DINT (RADIX := Decimal) := 0;
			C : DINT (RADIX := Decimal) := 0;
			MAX_UNIT_PROCS : DINT (RADIX := Decimal) := 16;
			MessageBuffer : DINT (RADIX := Decimal) := 200001;
			NewMessage : DINT (RADIX := Decimal) := 200001;
			S : DINT (RADIX := Decimal) := 16;
			Toggle : BOOL (RADIX := Decimal) := 0;
			U2 : DINT (RADIX := Decimal) := 59;
			U3 : DINT (RADIX := Decimal) := 0;
			U4 : DINT (RADIX := Decimal) := 0;
			U5 : DINT (RADIX := Decimal) := 0;
		END_TAG

		ROUTINE _00_CAMPAIGN_Main 
				RC: "===================================================================$N"
				    "CAMPAIGN  --  Generated By ControlBuilder, Copyright EZSoft, Inc. 2015$N"
				    "===================================================================$N"
				    "$N"
				    "==============================================================================$N"
				    "Revision History$N"
				    "==============================================================================$N"
				    "Rev$TDate$T$TDescription$T$T$T$TAuthor$N"
				    "==============================================================================     $N"
				    "1.0$T5/5/2010$TFusionFX Template Build$T$T$T$TBrian DeKorte$N"
				    "2.0$T7/1/2013$TFusionFX Template$T$T$T$TTerry Myers";
				N: [XIC(S:FS) JSR(_03_CAMPAIGN_FIRST_SCAN,0) ,JSR(_211_CAMPAIGN_STATE_TRANS,0) ,JSR(_212_CAMPAIGN_STEP_CNTRL,0) ,JSR(_242_CAMPAIGN_RUNNING,0) ];
				RC: "Record the last scan time of this program";
				N: GSV(Program,Campaign,LastScanTime,cCOMMON.SCAN_TIMES[10]);
		END_ROUTINE

		ROUTINE _03_CAMPAIGN_FIRST_SCAN (Description := "This routine is scanned only on the first scan of logic on power-up or program-to-run mode transition.")
				RC: "FIRST SCAN LOGIC$N"
				    "============================================================================$N"
				    "$N"
				    "Set all permissive bits for all campaigns$N"
				    "";
				N: NOP();
				N: MOV(0,S);
				N: LBL(SCHEDULE2)ADD(S,1,S);
				N: MOV(29,cSCHEDULE[S].CNTRL.LEN);
				RC: "Initialize permissive for each campaign";
				N: MOV(0,C);
				N: LBL(CAMPAIGN2)ADD(C,1,C);
				N: MOV(C,cSCHEDULE[S].CAMPAIGN[C].INDEX);
				N: OTE(cSCHEDULE[S].CAMPAIGN[C].STAT.PERMISSIVE);
				N: LES(C,cSETUP.NO_CAMPAIGN)JMP(CAMPAIGN2);
				N: LES(S,cSETUP.NO_SCHEDULE)JMP(SCHEDULE2);
		END_ROUTINE

		ROUTINE _211_CAMPAIGN_STATE_TRANS 
				N: NOP();
				N: MOV(0,S);
				N: LBL(SCHEDULE)ADD(S,1,S);
				N: MOV(S,cSCHEDULE[S].ARRAY_INDEX);
				N: AND(cSCHEDULE[S].CMD.BITS,cSCHEDULE[S].CMD.MASK,cSCHEDULE[S].CMD.BITS);
				N: NOT(cSCHEDULE[S].CMD.BITS,cSCHEDULE[S].CMD.MASK);
				RC: "New BDK 080123$N"
				    "$N"
				    "Initialize index to 1.$N"
				    "This controls visibility of start button on the campaign popup$N"
				    "if using the schedule auto mode.$N"
				    "this gets set inside loop to enable the appropriate campaign start button$N"
				    " $N"
				    "";
				N: MOV(1,cSCHEDULE[S].CAMPAIGN[0].INDEX);
				RC: "New BDK 080123$N"
				    "$N"
				    "Schedule Mode Logic$N"
				    " $N"
				    "";
				N: XIC(cSCHEDULE[S].CMD.AUTO)[OTL(cSCHEDULE[S].STAT.AUTO) ,OTU(cSCHEDULE[S].STAT.MAN) ];
				RC: "New BDK 080123$N"
				    "$N"
				    "Default to manual mode if not in any mode$N"
				    " $N"
				    "";
				N: [XIC(cSCHEDULE[S].CMD.MAN) ,XIO(cSCHEDULE[S].STAT.AUTO) XIO(cSCHEDULE[S].STAT.MAN) ][OTU(cSCHEDULE[S].STAT.AUTO) ,OTL(cSCHEDULE[S].STAT.MAN) ];
				N: MOV(100,cSCHEDULE[S].STATE_NO);
				N: MOV(0,C);
				N: LBL(CAMPAIGN)ADD(C,1,C)MOV(C,cSCHEDULE[S].CAMPAIGN[C].ID)MOV(C,cSCHEDULE[S].CAMPAIGN[C].INDEX);
				N: AND(cSCHEDULE[S].CAMPAIGN[C].CMD.BITS,cSCHEDULE[S].CAMPAIGN[C].CMD.MASK,cSCHEDULE[S].CAMPAIGN[C].CMD.BITS);
				N: NOT(cSCHEDULE[S].CAMPAIGN[C].CMD.BITS,cSCHEDULE[S].CAMPAIGN[C].CMD.MASK);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.IDLE)EQU(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,100)XIO(cSCHEDULE[S].CAMPAIGN[C].CMD.START)JMP(SKIP_CAMPAIGN);
				RC: "New BDK 080123$N"
				    " $N"
				    "If the campaign is not idle, then enable the next campaign in the list.$N"
				    "";
				N: XIO(cSCHEDULE[S].CAMPAIGN[C].STATE.IDLE)[ADD(C,1,cSCHEDULE[S].CAMPAIGN[0].INDEX) ,EQU(C,15) XIC(cSCHEDULE[S].CAMPAIGN[1].STATE.IDLE) MOV(1,cSCHEDULE[S].CAMPAIGN[0].INDEX) ];
				N: [XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.HELD) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RESTARTING) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.HOLDING) ]MOV(50,cSCHEDULE[S].STATE_NO);
				N: [XIC(cSCHEDULE[S].CAMPAIGN[C].CMD.RESET) ,XIC(cSCHEDULE[S].CAMPAIGN[C].CMD.START) ,XIC(cSCHEDULE[S].CAMPAIGN[C].CMD.RESTART) ]MOV(0,cSCHEDULE[S].CAMPAIGN[C].MSG.MSG)MOV(0,cSCHEDULE[S].CAMPAIGN[C].MSG.FAULT)MOV(0,cSCHEDULE[S].CAMPAIGN[C].MSG.PERM);
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,10)[XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.ABORTING) XIC(cSCHEDULE[S].CAMPAIGN[C].STAT.ABORTING_COMPLETE) MOV(90,cSCHEDULE[S].CAMPAIGN[C].STATE_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STATE.ABORTING) ];
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,20)[XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.HOLDING) XIC(cSCHEDULE[S].CAMPAIGN[C].STAT.HOLDING_COMPLETE) MOV(60,cSCHEDULE[S].CAMPAIGN[C].STATE_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STATE.HOLDING) ];
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,30)[XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.STOPPING) XIC(cSCHEDULE[S].CAMPAIGN[C].STAT.STOPPING_COMPLETE) MOV(80,cSCHEDULE[S].CAMPAIGN[C].STATE_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STATE.STOPPING) ];
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,40)[XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RESTARTING) XIC(cSCHEDULE[S].CAMPAIGN[C].STAT.RESTARTING_COMPLETE) MOV(50,cSCHEDULE[S].CAMPAIGN[C].STATE_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STATE.RESTARTING) ];
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,50)[XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING) XIC(cSCHEDULE[S].CAMPAIGN[C].STEP.COMPLETE) MOV(70,cSCHEDULE[S].CAMPAIGN[C].STATE_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING) ];
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,60)OTE(cSCHEDULE[S].CAMPAIGN[C].STATE.HELD);
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,70)OTE(cSCHEDULE[S].CAMPAIGN[C].STATE.COMPLETE);
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,80)OTE(cSCHEDULE[S].CAMPAIGN[C].STATE.STOPPED);
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,90)OTE(cSCHEDULE[S].CAMPAIGN[C].STATE.ABORTED);
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,100)OTE(cSCHEDULE[S].CAMPAIGN[C].STATE.IDLE);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].CMD.ABORT)[XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RESTARTING) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.HOLDING) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.HELD) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.STOPPING) ]MOV(10,cSCHEDULE[S].CAMPAIGN[C].STATE_NO);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].CMD.HOLD)[XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RESTARTING) ]MOV(20,cSCHEDULE[S].CAMPAIGN[C].STATE_NO);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].CMD.STOP)[XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RESTARTING) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.HOLDING) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.HELD) ]MOV(30,cSCHEDULE[S].CAMPAIGN[C].STATE_NO);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].CMD.RESET)[XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.COMPLETE) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.ABORTED) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.STOPPED) ][MOV(100,cSCHEDULE[S].CAMPAIGN[C].STATE_NO) ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].BATCH.COMPLETED) ];
				RC: "CMD.BITS.28 is Clear All Complete command from OIT$N"
				    "DOM SC did not eant to clear recipe info$N"
				    " $N"
				    "";
				N: AFI()XIC(cSCHEDULE[S].CMD.BITS.28)XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.COMPLETE)[MOV(100,cSCHEDULE[S].CAMPAIGN[C].STATE_NO) ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].BATCH.COMPLETED) ,MOV(100,cSCHEDULE[S].CAMPAIGN[C].BATCH.SIZE) ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].BATCH.REQUIRED) ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].BATCH.NUMBER) ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].RECIPE[0].ID) ,COP(cLINE[0].RECIPE.NAME,cSCHEDULE[S].CAMPAIGN[C].RECIPE[0].NAME,1) ,COP(cLINE[0].RECIPE.HEADER.NUMBER,cSCHEDULE[S].CAMPAIGN[C].RECIPE[0].NUMBER,1) ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].RECIPE[1].ID) ,COP(cLINE[0].RECIPE.NAME,cSCHEDULE[S].CAMPAIGN[C].RECIPE[1].NAME,1) ,COP(cLINE[0].RECIPE.HEADER.NUMBER,cSCHEDULE[S].CAMPAIGN[C].RECIPE[1].NUMBER,1) ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].RECIPE[2].ID) ,COP(cLINE[0].RECIPE.NAME,cSCHEDULE[S].CAMPAIGN[C].RECIPE[2].NAME,1) ,COP(cLINE[0].RECIPE.HEADER.NUMBER,cSCHEDULE[S].CAMPAIGN[C].RECIPE[2].NUMBER,1) ];
				RC: "CMD.BITS.28 is Clear All Complete command from OIT";
				N: XIC(cSCHEDULE[S].CMD.BITS.28)XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.COMPLETE)[MOV(100,cSCHEDULE[S].CAMPAIGN[C].STATE_NO) ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].BATCH.COMPLETED) ,MOV(100,cSCHEDULE[S].CAMPAIGN[C].BATCH.SIZE) ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].BATCH.NUMBER) ];
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].CMD.RESTART)XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.HELD)[EQU(cSCHEDULE[S].INDEX_C1,0) ,EQU(cSCHEDULE[S].INDEX_C1,C) ,EQU(cSCHEDULE[S].INDEX_C2,0) ,EQU(cSCHEDULE[S].INDEX_C2,C) ]MOV(40,cSCHEDULE[S].CAMPAIGN[C].STATE_NO);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].CMD.START)XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.IDLE)[EQU(cSCHEDULE[S].INDEX_C1,0) ,EQU(cSCHEDULE[S].INDEX_C2,0) ]MOV(50,cSCHEDULE[S].CAMPAIGN[C].STATE_NO);
				N: [XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RESTARTING) ]NEQ(cSCHEDULE[S].CAMPAIGN[C].MSG.FAULT,0)OTL(cSCHEDULE[S].CAMPAIGN[C].CMD.ABORT);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.STOPPED)EQU(C,16)OTL(cSCHEDULE[S].CAMPAIGN[C].CMD.RESET);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].CMD.CLEAR_FAILURE)MOV(0,cSCHEDULE[S].CAMPAIGN[C].MSG.FAULT);
				N: NEQ(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,10)NEQ(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,20)NEQ(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,30)NEQ(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,40)NEQ(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,50)NEQ(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,60)NEQ(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,70)NEQ(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,80)NEQ(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,90)NEQ(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,100)MOV(100,cSCHEDULE[S].CAMPAIGN[C].STATE_NO);
				RC: "NextSchedule$N"
				    "";
				N: LBL(SKIP_CAMPAIGN)NOP();
				RC: "NextSchedule$N"
				    "";
				N: XIC(cSCHEDULE[S].NEXT.CAMPAIGN[0].CMD.ACK)[MOV(cSCHEDULE[S].NEXT.ID,cSCHEDULE[S].ID) COP(cSCHEDULE[S].NEXT.NAME,cSCHEDULE[S].NAME,1) MOV(cCOMMON.TIME_BASED_ID,cSCHEDULE[S].PROC_ID) ,MOV(cSCHEDULE[S].ID,cSCHEDULE[S].NEXT.CAMPAIGN[C].SCHEDULE_ID) MOV(cCOMMON.TIME_BASED_ID,cSCHEDULE[S].NEXT.CAMPAIGN[C].SCHEDULE_PROC_ID) ];
				RC: "NextSchedule$N"
				    "$N"
				    "When a new schedule is downloaded, the next id is copied into each campaign tag.$N"
				    "Whenever this id is non-zero and also not equal to the currently loaded schedule id in the active campaign tag,$N"
				    "then if the campaign is idle or complete, then copy in the new campaign tag from next buffer.$N"
				    "this would make the schedule id$'s equal again which would then disable this copy instruction$N"
				    " $N"
				    "$N"
				    "";
				N: NEQ(cSCHEDULE[S].NEXT.CAMPAIGN[C].SCHEDULE_PROC_ID,0)NEQ(cSCHEDULE[S].CAMPAIGN[C].SCHEDULE_PROC_ID,cSCHEDULE[S].NEXT.CAMPAIGN[C].SCHEDULE_PROC_ID)[EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,1) ,EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,10) ]COP(cSCHEDULE[S].NEXT.CAMPAIGN[C],cSCHEDULE[S].CAMPAIGN[C],1);
				RC: "NextSchedule$N"
				    "$N"
				    "$N"
				    "";
				N: XIC(cSCHEDULE[S].NEXT.CAMPAIGN[0].CMD.RESET)COP(cSCHEDULE[0].NEXT.CAMPAIGN[0],cSCHEDULE[S].NEXT.CAMPAIGN[C],1);
				N: [LES(cSCHEDULE[S].NEXT.CAMPAIGN[C].BATCH.SIZE,50) MOV(50,cSCHEDULE[S].NEXT.CAMPAIGN[C].BATCH.SIZE) ,GRT(cSCHEDULE[S].NEXT.CAMPAIGN[C].BATCH.SIZE,100) MOV(100,cSCHEDULE[S].NEXT.CAMPAIGN[C].BATCH.SIZE) ];
				RC: "NextSchedule$N"
				    "";
				N: LES(C,cSETUP.NO_CAMPAIGN)JMP(CAMPAIGN);
				RC: "NextSchedule$N"
				    "$N"
				    "Clear the next schedule download buffer.$N"
				    "HMI sets this command bit then waits for a delay.$N"
				    "get the current time-based-id from the common tag$N"
				    "(number of seconds since a momemt in the past)$N"
				    "copy this value into the campaign tag so that even if we are downloading the same schedule$N"
				    "it will update it if there has been any changes$N"
				    "$N"
				    "$N"
				    "";
				N: XIC(cSCHEDULE[S].NEXT.CAMPAIGN[0].CMD.RESET)OTU(cSCHEDULE[S].NEXT.CAMPAIGN[0].CMD.RESET);
				RC: "NextSchedule$N"
				    "";
				N: XIC(cSCHEDULE[S].NEXT.CAMPAIGN[0].CMD.ACK)OTU(cSCHEDULE[S].NEXT.CAMPAIGN[0].CMD.ACK);
				RC: "CMD.BITS.28 is Clear All Complete command from OIT$N"
				    "Engine.NeedsReview:  this feature was only implemented for schedules 1, 7, and 8 in Topeka.$N"
				    "Evaluate if this is a useful feature for all jobs, name the command bit, possibly add an enable bit for the feature$N"
				    "";
				N: OTU(cSCHEDULE[S].CMD.BITS.28);
				N: LES(S,cSETUP.NO_SCHEDULE)JMP(SCHEDULE);
		END_ROUTINE

		ROUTINE _212_CAMPAIGN_STEP_CNTRL 
				N: NOP();
				N: MOV(0,S);
				N: LBL(SCHEDULE)ADD(S,1,S);
				RC: "CampaignPermissive$N"
				    "";
				N: [MOV(0,A) LIM(1,cSCHEDULE[S].LINE_A,cSETUP.NO_LINE) MOV(cSCHEDULE[S].LINE_A,A) ,MOV(0,B) LIM(1,cSCHEDULE[S].LINE_B,cSETUP.NO_LINE) MOV(cSCHEDULE[S].LINE_B,B) ];
				RC: "Initialize For Loop Index$N"
				    "===========================================================$N"
				    "For the Campaign Loop, start the index at 0, so that first time throught hte loop, the index is 1.$N"
				    "$N"
				    "NOTE:  Campaign 0 is a special case, the Phase Step logic for Campaign 0 is executed in CAMPAIGN_QUEUE$N"
				    " $N"
				    "";
				N: MOV(0,C);
				N: LBL(CAMPAIGN)ADD(C,1,C);
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,0)[XIC(cSCHEDULE[S].CAMPAIGN[C].STEP.RESET) MOV(1,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STEP.RESET) ];
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,1)[XIC(cSCHEDULE[S].CAMPAIGN[C].STEP.IDLE) XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING) [MOV(2,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) ,ONS(cSCHEDULE[S].CAMPAIGN[C].OS[3]) MOV(cCOMMON.TIME_BASED_ID,cSCHEDULE[S].CAMPAIGN[C].PROC_ID) ] ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STEP.IDLE) ];
				RC: "CampaignPermissive$N"
				    "";
				N: MOV(0,cSCHEDULE[S].CAMPAIGN[C].MSG.PERM);
				RC: "CampaignPermissive$N"
				    "$N"
				    "Two other campaigns already running$N"
				    "";
				N: NEQ(cSCHEDULE[S].INDEX_C1,0)NEQ(cSCHEDULE[S].INDEX_C1,C)NEQ(cSCHEDULE[S].INDEX_C2,0)NEQ(cSCHEDULE[S].INDEX_C2,C)MOV(1,cSCHEDULE[S].CAMPAIGN[C].MSG.PERM);
				RC: "CampaignPermissive$N"
				    "$N"
				    "No Orphan Batches Can be Running if you want to start a campaign$N"
				    "$N"
				    "";
				N: [XIO(cLINE[A].STATE.IDLE) EQU(cLINE[A].CAMPAIGN_INDEX,0) ,XIO(cLINE[B].STATE.IDLE) EQU(cLINE[B].CAMPAIGN_INDEX,0) ]MOV(2,cSCHEDULE[S].CAMPAIGN[C].MSG.PERM);
				RC: "Queue CampaignPermissive$N"
				    "$N"
				    "the Queue Campaign  can$'t be run if at least one other campaign is already running$N"
				    "$N"
				    "";
				N: EQU(C,16)[NEQ(cSCHEDULE[S].INDEX_C1,0) NEQ(cSCHEDULE[S].INDEX_C1,C) ,NEQ(cSCHEDULE[S].INDEX_C2,0) NEQ(cSCHEDULE[S].INDEX_C2,C) ]MOV(3,cSCHEDULE[S].CAMPAIGN[C].MSG.PERM);
				RC: "Campaign Permissive$N"
				    "$N"
				    "a normal campaign can not be run if the queue campaign is running$N"
				    "";
				N: NEQ(C,16)[NEQ(cSCHEDULE[S].INDEX_C1,0) EQU(cSCHEDULE[S].INDEX_C1,16) ,NEQ(cSCHEDULE[S].INDEX_C2,0) NEQ(cSCHEDULE[S].INDEX_C2,16) ]MOV(4,cSCHEDULE[S].CAMPAIGN[C].MSG.PERM);
				RC: "Enter batches required$N"
				    "";
				N: NEQ(C,16)LEQ(cSCHEDULE[S].CAMPAIGN[C].BATCH.REQUIRED,0)MOV(7,cSCHEDULE[S].CAMPAIGN[C].MSG.PERM);
				RC: "Enter batches required$N"
				    "";
				N: NEQ(C,16)EQU(cSCHEDULE[S].CAMPAIGN[C].RECIPE[0].ID,0)MOV(8,cSCHEDULE[S].CAMPAIGN[C].MSG.PERM);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.IDLE)EQU(cSCHEDULE[S].CAMPAIGN[C].MSG.PERM,0)MOV(11,cSCHEDULE[S].CAMPAIGN[C].MSG.PERM);
				N: [XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.COMPLETE) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.STOPPED) ]MOV(12,cSCHEDULE[S].CAMPAIGN[C].MSG.MSG);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.HELD)MOV(13,cSCHEDULE[S].CAMPAIGN[C].MSG.MSG);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.ABORTED)MOV(14,cSCHEDULE[S].CAMPAIGN[C].MSG.MSG);
				RC: "CampaignPermissive$N"
				    "";
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].MSG.PERM,0)OTE(cSCHEDULE[S].CAMPAIGN[C].STAT.PERMISSIVE);
				RC: "CampaignPermissive$N"
				    "";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.IDLE)[MOV(0,cSCHEDULE[S].CAMPAIGN[C].MSG.MSG) ,NEQ(cSCHEDULE[S].CAMPAIGN[C].MSG.PERM,0) MOV(cSCHEDULE[S].CAMPAIGN[C].MSG.PERM,cSCHEDULE[S].CAMPAIGN[C].MSG.MSG) ];
				RC: "Default batch size is 100";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.IDLE)ONS(cSCHEDULE[S].CAMPAIGN[C].OS[5])MOV(100,cSCHEDULE[S].CAMPAIGN[C].BATCH.SIZE);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.IDLE)EQU(cSCHEDULE[S].CAMPAIGN[C].STATE_NO,100)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,1)JMP(SKIP_CAMPAIGN);
				RC: "Campaign 16 is the queue campaign.$N"
				    "it must ACQUIRE both campaign buffers.$N"
				    "normal and queue campaigns can not run at same time.$N"
				    "";
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,2)[NEQ(cSCHEDULE[S].INDEX_C2,C) EQU(cSCHEDULE[S].INDEX_C1,0) MOV(C,cSCHEDULE[S].INDEX_C1) ,NEQ(cSCHEDULE[S].INDEX_C1,C) EQU(cSCHEDULE[S].INDEX_C2,0) MOV(C,cSCHEDULE[S].INDEX_C2) ,EQU(C,16) EQU(cSCHEDULE[S].INDEX_C1,0) MOV(C,cSCHEDULE[S].INDEX_C1) ,EQU(C,16) EQU(cSCHEDULE[S].INDEX_C2,0) MOV(C,cSCHEDULE[S].INDEX_C2) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STEP.RECORD) ];
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,3)OTE(cSCHEDULE[S].CAMPAIGN[C].STEP.PERMISSIVE);
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,4)OTE(cSCHEDULE[S].CAMPAIGN[C].STEP.INITIALIZE);
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,5)[XIC(cSCHEDULE[S].CAMPAIGN[C].STEP.ACTIVE) XIC(cSCHEDULE[S].CAMPAIGN[C].STAT.COMPLETE) MOV(6,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STEP.ACTIVE) ];
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,6)[XIC(cSCHEDULE[S].CAMPAIGN[C].STEP.SETTLE) MOV(7,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STEP.SETTLE) ];
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,7)[XIC(cSCHEDULE[S].CAMPAIGN[C].STEP.CALC) MOV(8,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STEP.CALC) ];
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,8)[XIC(cSCHEDULE[S].CAMPAIGN[C].STEP.REPORT) MOV(10,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STEP.REPORT) ];
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,10)[XIC(cSCHEDULE[S].CAMPAIGN[C].STEP.COMPLETE) XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.IDLE) MOV(0,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STEP.COMPLETE) ];
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,11)OTE(cSCHEDULE[S].CAMPAIGN[C].STEP.HELD);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RESTARTING)[ONS(cSCHEDULE[S].CAMPAIGN[C].OS[0]) [EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_REM,0) MOV(5,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) ,NEQ(cSCHEDULE[S].CAMPAIGN[C].STEP_REM,0) MOV(cSCHEDULE[S].CAMPAIGN[C].STEP_REM,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) MOV(0,cSCHEDULE[S].CAMPAIGN[C].STEP_REM) ] ,OTE(cSCHEDULE[S].CAMPAIGN[C].STAT.RESTARTING_COMPLETE) ];
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.HOLDING)[NEQ(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,11) MOV(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,cSCHEDULE[S].CAMPAIGN[C].STEP_REM) ,MOV(11,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STAT.HOLDING_COMPLETE) ];
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.STOPPING)[MOV(10,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STAT.STOPPING_COMPLETE) ];
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.ABORTING)[MOV(0,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) ,OTE(cSCHEDULE[S].CAMPAIGN[C].STAT.ABORTING_COMPLETE) ];
				N: [GRT(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,11) ,LES(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,0) ]NEQ(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,30)MOV(0,cSCHEDULE[S].CAMPAIGN[C].STEP_NO);
				N: [XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.COMPLETE) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.STOPPED) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.ABORTED) ]EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,10)MOV(1000,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX);
				N: LBL(SKIP_CAMPAIGN)LES(C,cSETUP.NO_CAMPAIGN)JMP(CAMPAIGN);
				N: LES(S,cSETUP.NO_SCHEDULE)JMP(SCHEDULE);
		END_ROUTINE

		ROUTINE _242_CAMPAIGN_RUNNING 
				RC: "CAMPAIGN CONTROL LOGIC$N"
				    "==================================================================$N"
				    "$N"
				    "The purpose of this routine is to control the execution of up to 2 campaigns in parallel.$N"
				    "A campaign is a series of batches.$N"
				    "The campaign logic is basically the same as typical phase logic.  it uses the same state machine, and similar step engine.$N"
				    "The step index is used to define the custom phsae logic (campaign logic)$N"
				    "$N"
				    "The campign must first ACQUIRE a line buffer to use to execute the first batch.$N"
				    "The next batch will be executed on the other buffer and so forth unti lthe last batch in the campaign.$N"
				    "The recipe is downloaded before runing the first batch.$N"
				    "The campaign waits for up to 2 minutes for the recipe to download and then faults.$N"
				    "$N"
				    "When the campaign launches a batch it waits to see if that batch is running, then when it sees that$N"
				    "batch is done with the ingredients system for good, the campaign then attempts to ACQUIRE the other buffer.$N"
				    "and launch the next batch on the other buffer, this continues until the last batch is launch at swhich time$N"
				    "the campaign jumps to the final step to wait for that batch to be done.$N"
				    " $N"
				    "";
				N: NOP();
				RC: "Initialize the loop variable";
				N: MOV(0,S);
				RC: "LOOP FOR ALL SCHEDULES IN THE SYSTEM$N"
				    "";
				N: LBL(SCHEDULE)ADD(S,1,S);
				RC: "Get the Line Array Indices that this schedule is operating on.$N"
				    "";
				N: [MOV(0,A) LIM(1,cSCHEDULE[S].LINE_A,cSETUP.NO_LINE) MOV(cSCHEDULE[S].LINE_A,A) ,MOV(0,B) LIM(1,cSCHEDULE[S].LINE_B,cSETUP.NO_LINE) MOV(cSCHEDULE[S].LINE_B,B) ];
				RC: "INITIALIZE LOOP INDEX";
				N: MOV(0,W);
				RC: "this campaign logic is executed with C as the index in the CAMPAIGN array.$N"
				    "The loop may be executed up to 2 times in this logic scan.$N"
				    "If there is no campaign to process, the logic is skipped.$N"
				    " $N"
				    "Run this For Each Campaign";
				N: LBL(CAMPAIGN)ADD(1,W,W);
				RC: "Pick which campaign to process $N"
				    " ";
				N: [EQU(W,1) MOV(cSCHEDULE[S].INDEX_C1,C) ,EQU(W,2) MOV(cSCHEDULE[S].INDEX_C2,C) ];
				RC: "If there is no campaign, then skip the logic$N"
				    "$N"
				    "";
				N: [EQU(C,0) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.IDLE) ,EQU(cSCHEDULE[S].INDEX_C1,16) ,EQU(cSCHEDULE[S].INDEX_C2,16) ]JMP(SKIP_CAMPAIGN);
				RC: "20070206\Restart";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RESTARTING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,310)MOV(300,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX);
				RC: "load up z with the line index that this campaign owns$N"
				    " $N"
				    "";
				N: MOV(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,Z);
				RC: "CAMPAIGN HAS JUST BEEN KICKED OFF - Initialize Data Registers and Step Index$N"
				    "==========================================================================================$N"
				    "$N"
				    " When the campaign is kicked off, clear the batch number and completed statistics, clear the line index, and start with step index 200.$N"
				    " $N"
				    "$N"
				    "";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,2)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,0)[MOV(0,cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX) ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].BATCH.NUMBER) ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].BATCH.COMPLETED) ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].ACTUAL[1]) ,MOV(200,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX) ,MOV(0,cSCHEDULE[S].CAMPAIGN[C].RECIPE_DOWNLOAD_HANDSHAKE) ,XIO(cLINE[Z].STAT.MAN) [MOV(cLINE[0].RECIPE.ID,cLINE[A].REC_BUF.RECIPE.ID) ,COP(cLINE[0].RECIPE.NAME,cLINE[A].REC_BUF.RECIPE.NAME,1) ,COP(cLINE[0].RECIPE.HEADER,cLINE[A].REC_BUF.RECIPE.HEADER,1) ,COP(cLINE[0].RECIPE.PRODUCT,cLINE[A].REC_BUF.RECIPE.PRODUCT,1) ,COP(cLINE[0].RECIPE.SPT[0],cLINE[A].REC_BUF.RECIPE.SPT[0],21) ,ADD(1,cSETUP.NO_STEPS_UNIT,MAX_UNIT_PROCS) ,COP(cLINE[0].RECIPE.STEP[0],cLINE[A].REC_BUF.RECIPE.STEP[0],MAX_UNIT_PROCS) ] ];
				N: XIO(cSCHEDULE[S].CAMPAIGN[C].STATE.IDLE)LES(cSCHEDULE[S].CAMPAIGN[C].BATCH.REQUIRED,cSCHEDULE[S].CAMPAIGN[C].BATCH.NUMBER)MOV(cSCHEDULE[S].CAMPAIGN[C].BATCH.NUMBER,cSCHEDULE[S].CAMPAIGN[C].BATCH.REQUIRED);
				RC: "CAMPAIGN PHASE COMPLETE$N"
				    "=====================================================================$N"
				    " $N"
				    " If the number of batches comleted is greater than or equal to number completed the go immediately to complete step.$N"
				    " $N"
				    "$N"
				    "$N"
				    "";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,2)[EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,200) ,EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,550) ]GEQ(cSCHEDULE[S].CAMPAIGN[C].BATCH.COMPLETED,cSCHEDULE[S].CAMPAIGN[C].BATCH.REQUIRED)MOV(6,cSCHEDULE[S].CAMPAIGN[C].STEP_NO)MOV(1000,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX);
				RC: "CHOOSE AVAILABLE LINE BUFFER  -  Take Line Buffer, Default to Buffer A$N"
				    "=========================================================================$N"
				    " $N"
				    "Decide which of the Line Buffers the campaign is going to use to run the first batch.$N"
				    "If one of the line buffer$'s campaign index tags is 0 and the campaign has no yet chosen a buffer, $N"
				    "   then save that index into the LINE_INDEX tag for later use in indexing into the cLINE tag.$N"
				    "$N"
				    "$N"
				    "Default is Buffer A$N"
				    "$N"
				    "";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,2)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,200)[EQU(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,0) XIC(cLINE[A].STATE.IDLE) EQU(cLINE[A].CAMPAIGN_INDEX,0) MOV(A,cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX) ,EQU(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,0) XIC(cLINE[B].STATE.IDLE) EQU(cLINE[B].CAMPAIGN_INDEX,0) MOV(B,cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX) ];
				RC: "LINE BUFFER ACQUIRED$N"
				    "====================================================$N"
				    " $N"
				    " Wait on this step until one of the line buffers has been acquired.$N"
				    " Write the campaign index of this campaign into the CAMPAIGN_INDEX of the chosen line buffer$N"
				    " If the other line buffer is currently not owned by any campaign and this campaign requires more than one batch, then take that line buffer as well.$N"
				    " $N"
				    "$N"
				    "";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,2)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,200)NEQ(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,0)[MOV(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,Z) ,MOV(C,cLINE[Z].CAMPAIGN_INDEX) ,EQU(Z,A) XIC(cLINE[B].STATE.IDLE) EQU(cLINE[B].CAMPAIGN_INDEX,0) GRT(cSCHEDULE[S].CAMPAIGN[C].BATCH.REQUIRED,1) MOV(C,cLINE[B].CAMPAIGN_INDEX) ,EQU(Z,B) XIC(cLINE[A].STATE.IDLE) EQU(cLINE[A].CAMPAIGN_INDEX,0) GRT(cSCHEDULE[S].CAMPAIGN[C].BATCH.REQUIRED,1) MOV(C,cLINE[A].CAMPAIGN_INDEX) ,MOV(3,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) MOV(300,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX) ];
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,3)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,300)[MOV(305,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX) ,XIC(cLINE[Z].STAT.MAN) MOV(320,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX) ];
				RC: "RECIPE DOWNLOAD REQUEST & CLEAR RECIPE DOWNLOAD BUFFER$N"
				    "==================================================================$N"
				    "$N"
				    "Choose the index, Y that will be used to index into the dOIT[Y].RECIPE_DOWNLOAD_REQUEST interface tag to actuall make the request for $N"
				    " recipe download from the current recipe download server.  The current recipe download server is determined in mcpMain\_11_COM_SCADA  $N"
				    "$N"
				    "Need to Cache the recipe download server id so that if it by chance is changed during the download request process, then we time out$N"
				    "instead of getting flipped through because the new server id indexes us into a different download request tag whose value is probably 0 at the time.$N"
				    " $N"
				    "";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,3)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,305)MOV(310,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX);
				RC: "HMI is Downloading Recipe$N"
				    " $N"
				    "The trigger for download is to set RECIPE[2].ID to a valid recipe id ( > 0)$N"
				    "HMI handshakes by writing same number down.$N"
				    " $N"
				    "Move Chosen Line Buffer into Z.$N"
				    "Start the Recipe Download Timeout Timer.$N"
				    "When download is handshaked, and Chosen Line Buffer is IDLE,$N"
				    "copy downloaded recipe to chosen line buffer.$N"
				    "If the other line buffer is also owned by this campaign, then copy recipe to it as well.$N"
				    "Set the IS_MIX_BATCH bit so that this line buffer will be the PREWEIGH batch$N"
				    "goto step 4$N"
				    "Move 1 into the Size of Line Buffer because recipe we just moved into it has size factor 1.$N"
				    "this will get scaled in Line Common $N"
				    " $N"
				    "Modified BDK 080123 - goto step 315 so that recipe can be scaled before it is started$N"
				    "  and before it is copied to the other buffer$N"
				    " $N"
				    "$N"
				    "";
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,3)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,310)[MOV(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,Z) MUL(3.5,60000,cSCHEDULE[S].CAMPAIGN[C].TMR[1].PRE) TON(cSCHEDULE[S].CAMPAIGN[C].TMR[1],?,?) ,EQU(cSCHEDULE[S].CAMPAIGN[C].RECIPE_DOWNLOAD_HANDSHAKE,cSCHEDULE[S].CAMPAIGN[C].RECIPE[0].ID) XIC(cLINE[Z].STATE.IDLE) [COP(cLINE[A].REC_BUF.RECIPE,cLINE[Z].RECIPE,1) ,EQU(Z,A) OTL(cLINE[A].STAT.IS_MIX_BATCH) ,EQU(Z,B) OTL(cLINE[B].STAT.IS_MIX_BATCH) ,MOV(315,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX) ,MOV(100,cLINE[Z].RECIPE.BATCH.SIZE) MOV(100,cLINE[Z].RECIPE.BATCH.SIZE_REM) ] ];
				RC: "New BDK 080123$N"
				    "$N"
				    "this is a oneshot step, just goto 4 on the way to starting the first batch of the campaign$N"
				    " $N"
				    "";
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,3)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,317)MOV(4,cSCHEDULE[S].CAMPAIGN[C].STEP_NO);
				RC: "New BDK 080123$N"
				    "$N"
				    "recipe is now scaled, if the other line buffer is idle and owned by this campaign,$N"
				    "then go ahead and copy the newly scaled recipe to the other line buffer.$N"
				    "goto step 317$N"
				    " $N"
				    "";
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,3)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,316)MOV(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,Z)[EQU(Z,A) XIC(cLINE[B].STATE.IDLE) EQU(cLINE[B].CAMPAIGN_INDEX,C) COP(cLINE[A].RECIPE,cLINE[B].RECIPE,1) ,EQU(Z,B) XIC(cLINE[A].STATE.IDLE) EQU(cLINE[A].CAMPAIGN_INDEX,C) COP(cLINE[B].RECIPE,cLINE[A].RECIPE,1) ,MOV(317,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX) ];
				RC: "New BDK 080123$N"
				    "$N"
				    "Added this rung to control the scaling of the recipe in line common routine.$N"
				    "simply goto step 316, which then is used to scale recipe in line common$N"
				    " $N"
				    "";
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,3)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,315)MOV(316,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX);
				RC: "RECIPE DOWNLOAD FAILURE$N"
				    "==================================================================$N"
				    "$N"
				    "The recipe download fails if:$N"
				    "$N"
				    "1) HMI acks the download with a negative number, this indicates a failure to dowload from the server.$N"
				    "2) Download times out$N"
				    "3) There is no active download server available$N"
				    " $N"
				    "The campaign phase is held$N"
				    "$N"
				    " $N"
				    "";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,3)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,310)[LES(cSCHEDULE[S].CAMPAIGN[C].RECIPE_DOWNLOAD_HANDSHAKE,0) MOV(1,cSCHEDULE[S].CAMPAIGN[C].MSG.FAULT) MOV(200005,cSCHEDULE[S].CAMPAIGN[C].MSG.MSG) ,XIC(cSCHEDULE[S].CAMPAIGN[C].TMR[1].DN) MOV(2,cSCHEDULE[S].CAMPAIGN[C].MSG.FAULT) MOV(200004,cSCHEDULE[S].CAMPAIGN[C].MSG.MSG) ,EQU(cSCHEDULE[S].CAMPAIGN[C].RECIPE_DOWNLOAD_HANDSHAKE,-2) MOV(4,cSCHEDULE[S].CAMPAIGN[C].MSG.FAULT) MOV(200006,cSCHEDULE[S].CAMPAIGN[C].MSG.MSG) ,EQU(cSCHEDULE[S].CAMPAIGN[C].RECIPE_DOWNLOAD_HANDSHAKE,-3) MOV(5,cSCHEDULE[S].CAMPAIGN[C].MSG.FAULT) MOV(200007,cSCHEDULE[S].CAMPAIGN[C].MSG.MSG) ,EQU(cSCHEDULE[S].CAMPAIGN[C].RECIPE_DOWNLOAD_HANDSHAKE,-4) MOV(6,cSCHEDULE[S].CAMPAIGN[C].MSG.FAULT) MOV(200008,cSCHEDULE[S].CAMPAIGN[C].MSG.MSG) ,EQU(cSCHEDULE[S].CAMPAIGN[C].RECIPE_DOWNLOAD_HANDSHAKE,-5) MOV(7,cSCHEDULE[S].CAMPAIGN[C].MSG.FAULT) MOV(200010,cSCHEDULE[S].CAMPAIGN[C].MSG.MSG) ,EQU(cSCHEDULE[S].CAMPAIGN[C].RECIPE_DOWNLOAD_HANDSHAKE,-9) MOV(9,cSCHEDULE[S].CAMPAIGN[C].MSG.FAULT) MOV(200009,cSCHEDULE[S].CAMPAIGN[C].MSG.MSG) ];
				RC: "PASS THROUGH STEP - Goto Step 4$N"
				    "======================================";
				N: AFI()XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,3)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,320)MOV(4,cSCHEDULE[S].CAMPAIGN[C].STEP_NO);
				RC: "HMI is Downloading Recipe$N"
				    " $N"
				    "The trigger for download is to set RECIPE[2].ID to a valid recipe id ( > 0)$N"
				    "HMI handshakes by writing same number down.$N"
				    " $N"
				    "Move Chosen Line Buffer into Z.$N"
				    "Start the Recipe Download Timeout Timer.$N"
				    "When download is handshaked, and Chosen Line Buffer is IDLE,$N"
				    "copy downloaded recipe to chosen line buffer.$N"
				    "If the other line buffer is also owned by this campaign, then copy recipe to it as well.$N"
				    "Set the IS_MIX_BATCH bit so that this line buffer will be the PREWEIGH batch$N"
				    "goto step 4$N"
				    "Move 1 into the Size of Line Buffer because recipe we just moved into it has size factor 1.$N"
				    "this will get scaled in Line Common $N"
				    " $N"
				    "Modified BDK 080123 - goto step 315 so that recipe can be scaled before it is started$N"
				    "  and before it is copied to the other buffer$N"
				    " $N"
				    "$N"
				    "";
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,3)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,320)[MOV(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,Z) ,XIC(cLINE[Z].STATE.IDLE) [EQU(Z,A) OTL(cLINE[A].STAT.IS_MIX_BATCH) ,EQU(Z,B) OTL(cLINE[B].STAT.IS_MIX_BATCH) ,MOV(315,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX) ,MOV(100,cLINE[Z].RECIPE.BATCH.SIZE) MOV(100,cLINE[Z].RECIPE.BATCH.SIZE_REM) ] ];
				RC: "RECIPE IN LINE BUFFER IS VALID - Goto Step 5 Active$N"
				    "========================================================================$N"
				    " $N"
				    " When the correct recipe id appears in the chosen line buffer, then we are ready to start the first batch.$N"
				    "Move a 1 into the $'this is first batch$' flag, so that first batch gets held.$N"
				    " $N"
				    "$N"
				    "$N"
				    "";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,4)MOV(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,Z)[[EQU(cSCHEDULE[S].CAMPAIGN[C].RECIPE[0].ID,cLINE[Z].RECIPE.HEADER.ID) ,XIC(cLINE[Z].STAT.MAN) ] [MOV(500,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX) ,MOV(5,cSCHEDULE[S].CAMPAIGN[C].STEP_NO) ] ,MOV(-1,cLINE[Z].IPAR[11]) ];
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,5)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,550)[MOV(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,Z) MOV(0,Y) ,EQU(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,A) MOV(B,Y) ,EQU(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,B) MOV(A,Y) ,XIC(cLINE[Y].STATE.IDLE) EQU(cLINE[Y].CAMPAIGN_INDEX,C) MOV(0,cLINE[Y].CAMPAIGN_INDEX) ];
				RC: "When the campaign is on step 550, this means that the LAST Batch Of campaign is the current Mixer 6atch.$N"
				    "So when the Line Buffer is complete, the campaign is complete.$N"
				    " $N"
				    "old rung:$N"
				    "$N"
				    "EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,5)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,550)MOV(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,Z)[XIC(cLINE[Z].STATE.COMPLETE),XIC(cLINE[Z].STATE.STOPPED),XIC(cLINE[Z].STATE.ABORTED),XIC(cLINE[Z].STATE.IDLE)]OTE(cSCHEDULE[S].CAMPAIGN[C].STAT.COMPLETE);$N"
				    " $N"
				    "";
				N: EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,5)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,550)GEQ(cSCHEDULE[S].CAMPAIGN[C].BATCH.COMPLETED,cSCHEDULE[S].CAMPAIGN[C].BATCH.REQUIRED)OTE(cSCHEDULE[S].CAMPAIGN[C].STAT.COMPLETE);
				RC: "READY TO START FIRST BATCH$N"
				    "=================================================================$N"
				    " $N"
				    " When the line buffer is running, set the current buffer to be ingredients batch, goto 510$N"
				    " If the line buffer is aborted or stopped, goto step 520$N"
				    " $N"
				    "";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,5)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,500)[MOV(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,Z) ,XIC(cLINE[Z].STATE.RUNNING) MOV(510,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX) ,[XIC(cLINE[Z].STATE.ABORTED) ,XIC(cLINE[Z].STATE.STOPPED) ] MOV(520,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX) ];
				RC: "THE CURRENT LINE BUFFER IS DONE WITH INGREDIENTS SYSTEM - Is becoming Mixer 6atch$N"
				    "====================================================================================$N"
				    "$N"
				    " when the line buffer has no more procedures to run on the  hopper unit or is on its last UP on hopper unit (STAT.BITS.24)$N"
				    "  then when the hopper unit is not owned by this line buffer, go to step 520 to either kick off another batch$N"
				    "   or wait for the last batch of the campaign to end before completing the campaign.$N"
				    " $N"
				    "IPAR[3] contains array index of cLINE tag, so cLINE[2].IPAR[3] = 1, cLINE[2].IPAR[3] = 2, etc.$N"
				    "$N"
				    "It just so happens that 2X is the index into the cUNIT tag for the associated hopper unit.$N"
				    " $N"
				    "IF BATCH IS ABORTED OR STOPPED, Progress to step 520 to try start another batch on ohter buffer.$N"
				    " $N"
				    "$N"
				    "$N"
				    "";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,5)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,510)MOV(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,Z)MOV(cLINE[Z].RECIPE.STEP_NEEDS[2].UNIT_INDEX,U2)MOV(cLINE[Z].RECIPE.STEP_NEEDS[3].UNIT_INDEX,U3)MOV(cLINE[Z].RECIPE.STEP_NEEDS[4].UNIT_INDEX,U4)MOV(cLINE[Z].RECIPE.STEP_NEEDS[5].UNIT_INDEX,U5);
				RC: "THE CURRENT LINE BUFFER IS DONE WITH INGREDIENTS SYSTEM - Is becoming Mixer 6atch$N"
				    "====================================================================================$N"
				    "$N"
				    " when the line buffer has no more procedures to run on the  hopper unit or is on its last UP on hopper unit (STAT.BITS.24)$N"
				    "  then when the hopper unit is not owned by this line buffer, go to step 520 to either kick off another batch$N"
				    "   or wait for the last batch of the campaign to end before completing the campaign.$N"
				    " $N"
				    "IPAR[3] contains array index of cLINE tag, so cLINE[2].IPAR[3] = 1, cLINE[2].IPAR[3] = 2, etc.$N"
				    "$N"
				    "It just so happens that 2X is the index into the cUNIT tag for the associated hopper unit.$N"
				    " $N"
				    "IF BATCH IS ABORTED OR STOPPED, Progress to step 520 to try start another batch on ohter buffer.$N"
				    " $N"
				    "$N"
				    "$N"
				    "";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,5)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,510)[[XIC(cLINE[Z].STAT.REPEAT) XIO(cLINE[Z].STATE.ABORTED) [XIC(cLINE[Z].RECIPE.STEP_NEEDS[2].HAS_BEEN_ACQUIRED) XIO(cLINE[Z].RECIPE.STEP_NEEDS[2].STILL_REQUIRED) NEQ(cUNIT[U2].INDEX,Z) ,XIC(cLINE[Z].RECIPE.STEP_NEEDS[3].HAS_BEEN_ACQUIRED) XIO(cLINE[Z].RECIPE.STEP_NEEDS[3].STILL_REQUIRED) NEQ(cUNIT[U3].INDEX,Z) ,XIC(cLINE[Z].RECIPE.STEP_NEEDS[4].HAS_BEEN_ACQUIRED) XIO(cLINE[Z].RECIPE.STEP_NEEDS[4].STILL_REQUIRED) NEQ(cUNIT[U4].INDEX,Z) ,XIC(cLINE[Z].RECIPE.STEP_NEEDS[5].HAS_BEEN_ACQUIRED) XIO(cLINE[Z].RECIPE.STEP_NEEDS[5].STILL_REQUIRED) NEQ(cUNIT[U5].INDEX,Z) ] ,XIO(cLINE[Z].STAT.REPEAT) XIC(cLINE[Z].STATE.COMPLETE) ] ,XIC(cLINE[Z].STATE.IDLE) ]MOV(520,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,5)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,530)MOV(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,Z)GEQ(cSCHEDULE[S].CAMPAIGN[C].BATCH.NUMBER,cSCHEDULE[S].CAMPAIGN[C].BATCH.REQUIRED)[EQU(cLINE[A].CAMPAIGN_INDEX,C) GEQ(cLINE[A].RECIPE.BATCH.NUMBER,cSCHEDULE[S].CAMPAIGN[C].BATCH.NUMBER) [XIC(cLINE[A].STATE.COMPLETE) ,XIC(cLINE[A].STATE.STOPPED) ,XIC(cLINE[A].STATE.ABORTED) ] ,EQU(cLINE[B].CAMPAIGN_INDEX,C) GEQ(cLINE[B].RECIPE.BATCH.NUMBER,cSCHEDULE[S].CAMPAIGN[C].BATCH.NUMBER) [XIC(cLINE[B].STATE.COMPLETE) ,XIC(cLINE[B].STATE.STOPPED) ,XIC(cLINE[B].STATE.ABORTED) ] ]MOV(550,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,5)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,530)GEQ(cSCHEDULE[S].CAMPAIGN[C].BATCH.COMPLETED,cSCHEDULE[S].CAMPAIGN[C].BATCH.REQUIRED)[EQU(cLINE[A].CAMPAIGN_INDEX,C) XIC(cLINE[A].STATE.IDLE) ,NEQ(cLINE[A].CAMPAIGN_INDEX,C) ][EQU(cLINE[B].CAMPAIGN_INDEX,C) XIC(cLINE[B].STATE.IDLE) ,NEQ(cLINE[B].CAMPAIGN_INDEX,C) ]MOV(550,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX);
				N: MOV(0,Y);
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,5)[EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,530) ,EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,510) ]GEQ(cSCHEDULE[S].CAMPAIGN[C].BATCH.NUMBER,cSCHEDULE[S].CAMPAIGN[C].BATCH.REQUIRED)[MOV(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,Z) MOV(0,Y) ,EQU(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,A) MOV(B,Y) ,EQU(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,B) MOV(A,Y) ,XIC(cLINE[Y].STATE.IDLE) EQU(cLINE[Y].CAMPAIGN_INDEX,C) MOV(0,cLINE[Y].CAMPAIGN_INDEX) ];
				RC: "The campaign chooses the Line Buffer that it wil use to start the next batch.$N"
				    "$N"
				    "On 530, we are about to loop back to step index 500 and kick off the next batch of the campaign.$N"
				    "Copy the recipe from this buffer to the other buffer.$N"
				    "Update the LINE_INDEX of the campaign to the index of the Other Buffer.$N"
				    " $N"
				    "Master Line Index - index of line buffer that the recipe was originally downloaded to, it will be the master of the adjustment limits for the $N"
				    "  remainder of the campaign.$N"
				    " $N"
				    "$N"
				    "$N"
				    " $N"
				    "";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,5)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,530)LES(cSCHEDULE[S].CAMPAIGN[C].BATCH.NUMBER,cSCHEDULE[S].CAMPAIGN[C].BATCH.REQUIRED)[MOV(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,Z) MOV(0,Y) ,EQU(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,A) MOV(B,Y) ,EQU(cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX,B) MOV(A,Y) ,XIC(cLINE[Y].STATE.IDLE) [EQU(cLINE[Y].CAMPAIGN_INDEX,0) MOV(C,cLINE[Y].CAMPAIGN_INDEX) ,EQU(cLINE[Y].CAMPAIGN_INDEX,C) [COP(cLINE[Z].RECIPE,cLINE[Y].RECIPE,1) ,MOV(Y,cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX) ,MOV(500,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX) ] ] ];
				RC: "Line Buffer Z is the Ingredients Batch, is becoming the Mixer 6atch.$N"
				    "Set the IPAR[2] for HMI Animations of the LineA and LineB buffers in the Batch Control screen.$N"
				    " $N"
				    "Default goto 530 to loop back and kick off another batch under this campaign.$N"
				    "If The Hopper was just released by this batch, then assume there is a batch that is finishing off in the mixer,$N"
				    "  that batch in the mixer will be the last batch of the campaign.  Don$'t need to start another.$N"
				    "$N"
				    "IPAR[1] = $N"
				    "$N"
				    "1 = LineA is Mix and LineB is Ingr$N"
				    " $N"
				    "0 = LineA is Ingr and  LineB is Mix$N"
				    "for HMI Batch Control Screen$N"
				    " $N"
				    " $N"
				    "";
				N: XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.RUNNING)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_NO,5)EQU(cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX,520)MOV(530,cSCHEDULE[S].CAMPAIGN[C].STEP_INDEX);
				RC: "CAMPAIGN SETS LINE TO REPEAT MODE$N"
				    "$N"
				    "At the end of a campaign, if the line was in single then set it to repeat.$N"
				    "The one-shot is specifically put ahead of the .REPEAT so that this only happens$N"
				    "one time. This allows the user to put the campaign back into the SINGLE mode before$N"
				    "resetting the campaign, otherwise, it would go right back to repeat if the campaing$N"
				    "was still in complete, stopped, or aborted.$N"
				    " $N"
				    "$N"
				    "$N"
				    " ";
				N: [XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.COMPLETE) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.STOPPED) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.ABORTED) ]ONS(cLINE[A].OS[6])XIO(cLINE[A].STAT.REPEAT)OTL(cLINE[A].STAT.REPEAT);
				N: [XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.COMPLETE) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.STOPPED) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.ABORTED) ,XIC(cSCHEDULE[S].CAMPAIGN[C].STATE.IDLE) ][MOV(0,cSCHEDULE[S].CAMPAIGN[C].LINE_INDEX) ,EQU(cLINE[A].CAMPAIGN_INDEX,C) MOV(0,cLINE[A].CAMPAIGN_INDEX) MOV(0,cLINE[A].RECIPE.HEADER.ID) ,EQU(cLINE[B].CAMPAIGN_INDEX,C) MOV(0,cLINE[B].CAMPAIGN_INDEX) MOV(0,cLINE[B].RECIPE.HEADER.ID) ,EQU(cSCHEDULE[S].INDEX_C1,C) MOV(0,cSCHEDULE[S].INDEX_C1) ,EQU(cSCHEDULE[S].INDEX_C2,C) MOV(0,cSCHEDULE[S].INDEX_C2) ];
				RC: "INDEX_C2 not used anymore. ";
				N: LBL(SKIP_CAMPAIGN)LEQ(W,14)JMP(CAMPAIGN);
				N: LBL(SKIP_SCHEDULE)LES(S,cSETUP.NO_SCHEDULE)JMP(SCHEDULE);
		END_ROUTINE

		ROUTINE _99_Toggle_Message 
				RC: "=========================================================================================================$N"
				    "Subroutine:$T_98_Toggle_Message$N"
				    "Author:$T$TBrian G. DeKorte$N"
				    "Date:$T$T03/09/2005$N"
				    "Rev:$T$T4$N"
				    "=========================================================================================================$N"
				    "Description:$T$N"
				    "$N"
				    "$T$TThis subroutine takes a new message number and moves it into the message buffer tag.$N"
				    "$T$TThe message buffer tag is linked to message text in SCADA based on look-up-table entry.$N"
				    "$T$TThe Toggle tag is passed in, when toggle is set, the message buffer is cleared or $'released$'.$N"
				    "$T$TThe next message in line will be allowed to $'ACQUIRE$' the message buffer tag.$N"
				    "$N"
				    "";
				N: SBR(NewMessage,MessageBuffer,Toggle)NOP();
				N: [EQU(MessageBuffer,0) MOV(NewMessage,MessageBuffer) ,EQU(MessageBuffer,NewMessage) XIC(Toggle) CLR(MessageBuffer) OTU(Toggle) ];
				N: RET(MessageBuffer,Toggle);
		END_ROUTINE

		CHILD_PROGRAMS
		END_CHILD_PROGRAMS

	END_PROGRAM
